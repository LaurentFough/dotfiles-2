#!/usr/bin/env bash

version="2.0.0"

_mainScript_() {
  local user
  local uid
  local finder_pid

  user=$(whoami)
  uid=$(id -u "$user")
  #shellcheck disable=2009
  finder_pid=$(ps -u "$user" | grep /System/Library/CoreServices/Finder.app | grep -v grep | awk '{print $1}')

  _have_scriptable_finder_() {
    # Determine whether we can script the Finder or not
    # We must have a valid PID for Finder, plus we cannot be in
    # `screen` (another thing that's broken)
    if [[ (${finder_pid} -gt 1) && ("$STY" == "") ]]; then
      if ${bypassFinder}; then
        return 1
      else
        return 0
      fi
    else
      return 1
    fi
  }

  _realpath_() {
    # Convert a relative path to an absolute path.
    #
    # From http://github.com/morgant/realpath
    #
    # @param string the string to converted from a relative path to an absolute path
    # @returns Outputs the absolute path to STDOUT, returns 0 if successful or 1 if
    # an error (esp. path not found).
    local successPath=true
    local path="$1"

    # make sure the string isn't empty as that implies something in further logic
    if [ -z "$path" ]; then
      successPath=false
    else
      # start with the file name (sans the trailing slash)
      path="${path%/}"

      # if we stripped off the trailing slash and were left with nothing, that means we're in the root directory
      if [ -z "$path" ]; then
        path="/"
      fi

      # get the basename of the file (ignoring '.' & '..', because they're really part of the path)
      local file_basename="${path##*/}"
      if [[ ( "$file_basename" = "." ) || ( "$file_basename" = ".." ) ]]; then
        file_basename=""
      fi

      # extracts the directory component of the full path, if it's empty then assume '.' (the current working directory)
      local directory="${path%$file_basename}"
      if [ -z "$directory" ]; then
        directory='.'
      fi

      # attempt to change to the directory
      if ! cd "${directory}" &>/dev/null ; then
        successPath=false
      fi

      if ${successPath}; then
        # does the filename exist?
        if [[ ( -n "${file_basename}" ) && ( ! -e "${file_basename}" ) ]]; then
          successPath=false
        fi

        # get the absolute path of the current directory & change back to previous directory
        local abs_path
        abs_path="$(pwd -P)"
        cd "-" &>/dev/null

        # Append base filename to absolute path
        if [ "${abs_path}" = "/" ]; then
          abs_path="${abs_path}${file_basename}"
        else
          abs_path="${abs_path}/${file_basename}"
        fi

        # output the absolute path
        echo "${abs_path}"
      fi
    fi

    ${successPath}
  }

  _listTrash_() {
    local num_volumes
    local total_blocks
    local blocks
    local size

    num_volumes=0
    total_blocks=0

    notice "Listing items in Trash"

    # list file contents & calculate size for user's .Trash folder
    if find "/Users/${user}/.Trash" -depth 1 ! -depth 0; then
      num_volumes=$(( num_volumes + 1 ))
      blocks=$(du -cs "/Users/${user}/.Trash" | tail -n 1 | cut -f 1)
      total_blocks=$(( total_blocks + blocks ))
    fi
    # list file contents & calculate size for volume-specific .Trashes folders
    for file in /Volumes/*; do
      if [ -d "$file" ]; then
        folder="${file}/.Trashes/${uid}"
        if [ -d "${folder}" ]; then
          if find "${folder}" -depth 1 ! -depth 0; then
            num_volumes=$(( num_volumes + 1 ))
            blocks=$(du -cs "${folder}" | tail -n 1 | cut -f 1)
            total_blocks=$(( total_blocks + blocks ))
          fi
        fi
      fi
    done
    # convert blocks to human readable size
    size=0
    if (( total_blocks >= 2097152 )); then
      size=$(bc <<< "scale=2; ${total_blocks} / 2097152")
      size="${size}GB"
    elif (( total_blocks >= 2048 )); then
      size=$(bc <<< "scale=2; ${total_blocks} / 2048")
      size="${size}MB"
    else
      size=$(bc <<< "scale=2; ${total_blocks} / 2")
      size="${size}K"
    fi
    info "${size} across ${num_volumes} volume(s)."
  }

  _emptyTheTrash_() {
    # Determine if we can tell Finder to empty trash via AppleScript
    if _have_scriptable_finder_; then
      notice "Telling Finder to empty trash..."
      _execute_ "/usr/bin/osascript -e 'tell application \"Finder\" to empty trash'" "Trash emptied"
    else
       notice "Emptying trash..."

      # delete the contents of user's .Trash folder
      while read -r fileToTrash; do
        [ -e "$fileToTrash" ] && _execute_ "rm -rf \"$fileToTrash\""
      done< <(find "/Users/${user}/.Trash" -depth 1 ! -depth 0)

      # delete the contents of the volume-specific .Trashes folders
      for volume in /Volumes/*; do
        if [ -d "${volume}" ]; then
          folder="${volume}/.Trashes/${uid}"
          if [ -d "${folder}" ]; then
            while read -r fileToTrash; do
              [ -e "$fileToTrash" ] && _execute_ "rm -rf \"$fileToTrash\""
            done < <(find "${folder}" -depth 1 ! -depth 0)
          fi
        fi
      done
    fi
  }

  _trashAFile_() {
    # Iterate over all files passed by user
    for userFile in "${args[@]}"; do
      if [ ! -e "${userFile}" ]; then
        die "${userFile}: No such file or directory"
      fi
      # determine if we'll tell Finder to trash the file via AppleScript (very easy, plus free undo
      # support, but Finder must be running for the user and is DOES NOT work from within `screen`)
    if _have_scriptable_finder_; then
      # determine whether we have an absolute path name to the file or not
      if [ "${userFile:0:1}" = "/" ]; then
        local file="${userFile}"
      else
        # expand relative to absolute path
        verbose "Determining absolute path for '${userFile}'... "
        file="$(_realpath_ "${userFile}")"
        if [ $? -ne 0 ]; then
          warning "Could not determine absolute path for '${userFile}'!"
        fi
      fi
      verbose "Telling Finder to trash '${userFile}'..."

      _execute_ "/usr/bin/osascript -e 'tell application \"Finder\" to delete POSIX file \"$file\"' &>/dev/null" "'${userFile}' moved to trash"

    else
      verbose "Telling system to trash '${file}'..."
      local trash="/Users/${user}/.Trash/"
      # create the trash folder if necessary
      if [ ! -d "${trash}" ]; then
        _execute_ "mkdir \"${trash}\""
      fi
      local newBase="$(basename "${userFile}")"
      local new="$(_uniqueFileName_ "${trash}${newBase}")"
      _execute_ "mv \"${userFile}\" \"${new}\"" "'${userFile}' moved to trash"
    fi
    done
  }

  if ${list}; then _listTrash_; _safeExit_; fi
  if ${emptyTrash}; then _emptyTheTrash_; _safeExit_; fi
  # Default behavior without flags is to delete a file
  _trashAFile_
}  # end _mainScript_

_trapCleanup_() {
  echo ""
  die "Exit trapped. In function: '${FUNCNAME[*]:1}'"
}

_safeExit_() {
  trap - INT TERM EXIT
  exit ${1:-0}
}

# Set Base Variables
# ----------------------
scriptName=$(basename "$0")

# Set Flags
quiet=false;      printLog=false;       verbose=false;
strict=false;     dryrun=false;
debug=false;      args=();

list=false;       emptyTrash=false;    bypassFinder="false"

# Set Colors
bold=$(tput bold);        reset=$(tput sgr0);         purple=$(tput setaf 171);
red=$(tput setaf 1);      green=$(tput setaf 76);      tan=$(tput setaf 3);
blue=$(tput setaf 38);    underline=$(tput sgr 0 1);

# Logging & Feedback
logFile="${HOME}/Library/Logs/${scriptName%.sh}.log"

_alert_() {
  if [ "${1}" = "error" ]; then local color="${bold}${red}"; fi
  if [ "${1}" = "warning" ]; then local color="${red}"; fi
  if [ "${1}" = "success" ]; then local color="${green}"; fi
  if [ "${1}" = "debug" ]; then local color="${purple}"; fi
  if [ "${1}" = "header" ]; then local color="${bold}${tan}"; fi
  if [ "${1}" = "input" ]; then local color="${bold}"; fi
  if [ "${1}" = "dryrun" ]; then local color="${blue}"; fi
  if [ "${1}" = "info" ] || [ "${1}" = "notice" ]; then local color=""; fi
  # Don't use colors on pipes or non-recognized terminals
  if [[ "${TERM}" != "xterm"* ]] || [ -t 1 ]; then color=""; reset=""; fi

  # Print to console when script is not 'quiet'
  if ${quiet}; then tput cuu1 ; return; else # tput cuu1 moves cursor up one line
   echo -e "$(date +"%r") ${color}$(printf "[%7s]" "${1}") ${_message}${reset}";
  fi

  # Print to Logfile
  if ${printLog} && [ "${1}" != "input" ]; then
    color=""; reset="" # Don't use colors in logs
    echo -e "$(date +"%m-%d-%Y %r") $(printf "[%7s]" "${1}") ${_message}" >> "${logFile}";
  fi
}

function die ()       { local _message="${*} Exiting."; echo -e "$(_alert_ error)"; _safeExit_ "1";}
function error ()     { local _message="${*}"; echo -e "$(_alert_ error)"; }
function warning ()   { local _message="${*}"; echo -e "$(_alert_ warning)"; }
function notice ()    { local _message="${*}"; echo -e "$(_alert_ notice)"; }
function info ()      { local _message="${*}"; echo -e "$(_alert_ info)"; }
function debug ()     { local _message="${*}"; echo -e "$(_alert_ debug)"; }
function success ()   { local _message="${*}"; echo -e "$(_alert_ success)"; }
function dryrun()     { local _message="${*}"; echo -e "$(_alert_ dryrun)"; }
function input()      { local _message="${*}"; echo -n "$(_alert_ input)"; }
function header()     { local _message="== ${*} ==  "; echo -e "$(_alert_ header)"; }
function verbose()    { if ${verbose}; then debug "$@"; fi }


# Options and Usage
# -----------------------------------
_usage_() {
  echo -n "${scriptName} [OPTION]... [FILE]...

 ${bold}Trash${reset} allows MacOS trashing of files instead of tempting fate with ${bold}rm${reset}.
 Anything deleted with Trash will be moved to the native MacOS trash folder.

 This script:

  - Correctly handles ${bold}trashing files on other volumes${reset}
  - Uses the ${bold}same filename renaming scheme as Finder${reset} for duplicate file names
  - Can ${bold}list trash contents${reset} w/disk usage summary
  - ${bold}Empty trash${reset}.
  - Does not require Finder to be running.

 ${bold}Options:${reset}
  -l , --list         List trash contents
  -e, --empty         Empty trash contents
  -n, --dryrun        Non-destructive run. Will report on changes that would have
                      been made.
  --bypassFinder      Bypasses AppleScript. Runs pure unix commands.
  --log               Print log to file
  -q, --quiet         Quiet (no output)
  -v, --verbose       Output more information. (Items echoed to 'verbose')
  -d, --debug         Runs script in BASH debug mode (set -x)
  -h, --help          Display this help and exit
      --version       Output version information and exit
"
}

# Iterate over options breaking -ab into -a -b when needed and --foo=bar into
# --foo bar
optstring=h
unset options
while (($#)); do
  case $1 in
    # If option is of type -ab
    -[!-]?*)
      # Loop over each character starting with the second
      for ((i=1; i < ${#1}; i++)); do
        c=${1:i:1}

        # Add current char to options
        options+=("-$c")

        # If option takes a required argument, and it's not the last char make
        # the rest of the string its argument
        if [[ $optstring = *"$c:"* && ${1:i+1} ]]; then
          options+=("${1:i+1}")
          break
        fi
      done
      ;;

    # If option is of type --foo=bar
    --?*=*) options+=("${1%%=*}" "${1#*=}") ;;
    # add --endopts for --
    --) options+=(--endopts) ;;
    # Otherwise, nothing special
    *) options+=("$1") ;;
  esac
  shift
done
set -- "${options[@]}"
unset options

# Print help if no arguments were passed.
# Uncomment to force arguments when invoking the script
# -------------------------------------
[[ $# -eq 0 ]] && set -- "--help"

# Read the options and set stuff
while [[ $1 = -?* ]]; do
  case $1 in
    -h|--help) _usage_ >&2; _safeExit_ ;;
    --version) echo "$(basename $0) ${version}"; _safeExit_ ;;
    --bypassFinder) bypassFinder=true ;;

    -l|--list) list=true ;;
    -e|--empty) emptyTrash=true ;;
    -n|--dryrun) dryrun=true ;;
    -v|--verbose) verbose=true ;;
    --log) printLog=true ;;
    -q|--quiet) quiet=true ;;
    -s|--strict) strict=true;;
    -d|--debug) debug=true;;
    --endopts) shift; break ;;
    *) die "invalid option: '$1'." ;;
  esac
  shift
done

# Store the remaining part as arguments.
args+=("$@")

_execute_() {
  # _execute_ - wrap an external command in '_execute_' to push native output to /dev/null
  #           and have control over the display of the results.  In "dryrun" mode these
  #           commands are not executed at all. In Verbose mode, the commands are executed
  #           with results printed to stderr and stdin
  #
  # usage:
  #   _execute_ "cp -R \"~/dir/somefile.txt\" \"someNewFile.txt\"" "Optional message to print to user"
  if ${dryrun}; then
    dryrun "${2:-$1}"
  else
    if $verbose; then
      eval "$1"
    else
      eval "$1" &> /dev/null
    fi
    if [ $? -eq 0 ]; then
      success "${2:-$1}"
      return 0
    else
      warning "${2:-$1}"
      return 1
    fi
  fi
}

_uniqueFileName_() {
  # _uniqueFileName_ takes an input of a file and returns a unique filename.
  # The use-case here is trying to write a file to a directory which may already
  # have a file with the same name. To ensure unique filenames, we append a digit
  # to files when necessary
  #
  # Inputs:
  #
  #   $1  The name of the file (may include a directory)
  #
  #   $2  Option separation character. Defaults to a space
  #
  # Usage:
  #
  #   _uniqueFileName "/some/dir/file.txt" "-"
  #
  #   Would return "/some/dir/file-2.txt"

  local n origFull origName origExt newfile spacer

  origFull="$1"
  spacer="${2:- }"
  origName="${origFull%.*}"
  origExt="${origFull##*.}"
  newfile="${origName}.${origExt}"

  if [ -e "${newfile}" ]; then
    n=2
    while [[ -e "${origName}${spacer}${n}.${origExt}" ]]; do
      (( n++ ))
    done
    newfile="${origName}${spacer}${n}.${origExt}"
  fi

  echo "${newfile}"
}

# Trap bad exits with your cleanup function
trap _trapCleanup_ EXIT INT TERM

# Set IFS to preferred implementation
IFS=$' \n\t'

# Exit on error. Append '||true' when you run the script if you expect an error.
set -o errexit

# Run in debug mode, if set
if ${debug}; then set -x ; fi

# Exit on empty variable
if ${strict}; then set -o nounset ; fi

# Exit the script if a command fails
set -e

# Run your script
_mainScript_

# Exit cleanly
_safeExit_